package com.example.plugin.data

import java.io.Serializable

data class Settings(
    var s: String = "",
    var ruleList: MutableList<RuleElement> = listModelByDefault()
): Serializable

private fun listModelByDefault(): MutableList<RuleElement> {
    val listModel = mutableListOf<RuleElement>().apply {
        add(RuleElement(0, "Restriction of storing confidential data when entering - EditText in an Android app is able to remember the information you enter and offer it for autocompletion (even if it's sensitive information). " +
                "It is necessary to define the inputType = “textNoSuggestions” parameter in the EditText fields, whose id is responsible for credit cards, passwords, PIN codes. It will disable the ability to autocomplete the text field and remember the entered value.", true))
        add(RuleElement(1, "Checking the file for relevance to the current project - When working with files, before giving users access to files, it is necessary to check whether this file is truly related to the application. In such a case, using absolutePath would be erroneous, since a single file in the file system can have an infinite number of absolute paths. " +
                "It is necessary to use the canonicalPath parameter instead of absolutePath. Because the canonical path is always unique.", true))
        add(RuleElement(2, "Disabling file access from WebView - Checks for WebView settings options to prevent access to arbitrary local files or launching XSS attacks. " +
                "You need to disable the ability to access external files using the WebView. Here it is possible by setting the WebView settings attributes “allowFileAccess = false”, “allowContentAccess = false”.", true))
        add(RuleElement(3, "Disabling external access to Android application components - Android application components must explicitly set the android:exported attribute to prevent external applications from accessing it. " +
                "To prevent access to application components, it is necessary to explicitly set “android:exported = false” in the manifest.xml file for each of them.", true))
        add(RuleElement(4, "An additional level of protection when visiting sites - With WebView, Android apps can interact with browsers. Sites can be insecure and malicious. To protect against visiting such sites, an additional layer of WebView protection is required. " +
                "To do this, include the following expression in the manifest.xml file: <meta-data android:name=”android.webkit.WebView.EnableSafeBrowsing” android:value=”true” />", true))
        add(RuleElement(5, "Checking expected URLs - To display sites in a WebView, URLs must be passed through an Intent. This list may include malicious addresses that the developer does not expect to see. " +
                "To protect against unexpected sites, you need to create a list of addresses that should be intercepted and get into the WebView. It is necessary in the shouldOverrideUrlLoading() method of the WebViewClient to match incoming URLs with a list of expected addresses.", true))
        add(RuleElement(6, "Network Configuration Declaration - The Network Security Configuration feature allows you to configure which CAs are trusted to secure connections from an application. They protect applications from accidentally using unencrypted traffic. " +
                "To do this, add the parameter android:networkSecurityConfig=”@xml/network_security_config” to the application configuration in the manifest.xml file.", true))
        add(RuleElement(7, "Restricting access to local content in WebView -  Should not use the setAllowUniversalAccessFromFileURLs() method to access local content. Enabling this setting allows malicious scripts loaded in the file:// context to launch cross-site scripting attacks or access arbitrary local files, including WebView cookies. " +
                "Instead of using the setAllowUniversalAccessFromFileURLs() method, you need to use androidx.webkit.WebViewAssetLoader to securely load file content.", true))
        add(RuleElement(8, "Declaring the security level of application components that exchange content - All Android app components that share content between apps should use android:protectionLevel=”signature” for custom permissions. Applications should not rely on access to a list of installed packages. " +
                "In the manifest.xml file in the application components, you must explicitly specify the android:protectionLevel=”signature” parameter in the permission tag.", true))
        add(RuleElement(9, "Setting PendingIntents with an immutable flag - The FLAG_IMMUTABLE flag must be specified when setting the PendingIntent. This means that the extra intent argument passed to the dispatch methods to populate the unpopulated properties of that intent will be ignored. " +
                "When configuring pendingIntent, you must specify PendingIntent.FLAG_IMMUTABLE in the object creation parameters.", true))
        add(RuleElement(10, "Single access to data when exchanging between applications - When exchanging data between applications, you should provide one-time access to data for writing and reading. " +
                "To do this, add the following flags to the Intent using the addFlags() method: FLAG_GRANT_READ_URI_PERMISSION, FLAG_GRANT_WRITE_URI_PERMISSION.", true))
        add(RuleElement(11, "Sharing data between applications - When sharing data, you must use content:// instead of file:// in the URI. " +
                "As an example, to provide the display of a PDF file in a standalone application - Uri.parse(\"content://com.example/example.pdf\")", true))
        add(RuleElement(12, "Permissions for actions that can be performed in another application - Do not use permissions for actions that can be performed in another application that already has permissions to do so. So, you need to use redirect intents with the appropriate requests. " +
                "For example, instead of using the READ_CONTACTS, WRITE_CONTACTS permissions in your application, you need to redirect the user in the Contacts application, which already has permissions to do so. Intent(Intent.ACTION_INSERT).apply { type = ContactsContract.Contacts.CONTENT_TYPE}.also {intent -> intent.resolveActivity(packageManager)?.startActivity(intent) }", true))
        add(RuleElement(13, "Specifying the type of the EditText field to be filled with sensitive data - The autocomplete service determines the type of each view using heuristics. Using them when updating the application may change the behavior of autocomplete. You need to provide autocomplete hints for this. " +
                "Autofill hints can be set using the android:autofillHints attribute. It is necessary in the EditText fields, the id of which is responsible for credit cards, passwords, PIN codes, username, to determine the type of the autifillHints constant depending on the id.", true))
        add(RuleElement(14, "Storing data in the application's internal memory - It is necessary to store all sensitive data in the internal memory of the device, isolated for each application. Other applications cannot access it. When the user deletes the application, all data stored in the internal memory is deleted. " +
                "You must use cryptographic keys to encrypt sensitive data. Writing to the internal memory can be done as follows in such a case: “encryptedFile = EncryptedFile.Builder(File(directory, fileToWriteName), applicationContext, mainKeyAlias, EncryptedFile.FileEncryptedScheme.AES256_GCM_HKDF_4KB).build()”", true))
        add(RuleElement(15, "Using cryptographic algorithms provided by the platform - When developing an application, you must use cryptographic algorithms that are provided by the platform, and not your own. Using proven and reliable algorithms will ensure stability. " +
                "To securely read and write local file files, you must use the Security library. You must use existing cryptographic algorithms such as the AES and RSA implementations, provided in the Cipher class. It is also recommended to use 256-bit algorithm.", true))
        add(RuleElement(16, "Proper SSL Handling - When communicating over HTTPS, an SSLException can occur as a result of a server certificate validation error or a man-in-the-middle attack. To be safe, you should handle this exception and not try to retry the connection using insecure HTTP. " +
                "To do this, you need to override the onReceivedSslError() method. In the body of the method, describe the following example code: “error?.also{createSslErrorDialog(it, context)?.show() handler.cancel()}”. In the createErrorDialog method, you need to describe the creation of an AlertDialog with detailed error information depending on the SslError type.", true))
        add(RuleElement(17, "Using the HTTPS protocol - You must use HTTPS instead of HTTP to communicate with servers because there is a potential risk of services being spoofed by attackers. This protocol allows you to encrypt data that is sent between your device and a website or service. " +
                "You must use the HTTPS protocol in the URLs used to make requests to the server. Also this https should be used in the security protocol.", true))
        add(RuleElement(18, "Server hostnames must be checked during SSL/TLS connections - To protect against man-in-the-middle attacks, you need to make sure that the server provides the correct certificate. The data related to the hostname must match the hostname of the server. " +
                "For example, when using the okhttp library, you should not override the hostnameVerifier object, since the library already uses a built-in secure one. Thus, the following construct should be avoided in code: builder.hostnameVerifier(object: HostnameVerifier { override fun verify(): Boolean { return true} })", true))
        add(RuleElement(19, "Server certificates must be validated during SSL/TLS connections - Certificate validation is necessary to create secure SSL/TLS sessions that are immune to attacks from outsiders. The TLS libraries provide built-in certificate validation functions that should be used. " +
                "You should not override the certificate validation functions, that is, the TrustManager class object and its functions. It will be enough to use the following code construct: “sslContext=SSLContent.getInstance(“SSL”)\n" +
                "sslContext.init(null, null, java.security.SecureRandom())”. Where the second parameter of the init() method is responsible for the certificate verification object, which contains the necessary approach by default.", true))
        add(RuleElement(20, "Checking BroadcastReceiver Permissions - An application registers a broadcast receiver without specifying sender permission requirements. " +
                "This requires the use of permission flags when registering a broadcast message receiver. That is, the following registration option is required: “context.registerReceiver(broadcastReceiver, intentFilter, “permission.ALLOW_BROADCAST”, handler)”. That is, you must explicitly specify the permissions that the sender must have.",true))
    }
    return listModel
}